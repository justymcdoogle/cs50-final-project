from flask import Flask, render_template, request, session, redirect, flash
from flask_session import Session
from werkzeug.security import check_password_hash, generate_password_hash
from cs50 import SQL

from helpers import login_required 

VALID_SECTIONS = ["verse", "chorus", "bridge", "intro", "outro"]

# Configure application
app = Flask(__name__)

# Configure session to use filesystem (instead of signed cookies)
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)

# Database
db = SQL("sqlite:///tabs.db")

@app.route("/register", methods=["GET", "POST"])
def register():
    """Register user"""

    if request.method == "POST":
        if not request.form.get("username"):
            return "No username :("

        password = request.form.get("password")
        if not password:
            return "No password :("

        if not request.form.get("confirmation"):
            return "No confirmation :("
        
        rows = db.execute(
            "SELECT username FROM users WHERE username = ?",
            request.form.get("username")
        )

        if len(rows) > 0:
            return "Username not unique :("
        
        if request.form.get("password") != request.form.get("confirmation"):
            return "Confirmation must match password :("

        hashed_password = generate_password_hash(password)

        db.execute(
            "INSERT INTO users (username, hash) VALUES (?, ?)",
            request.form.get("username"),
            hashed_password,
        )

        rows = db.execute(
            "SELECT id FROM users WHERE username = ?",
            request.form.get("username")
        )

        session["user_id"] = rows[0]['id']

        return redirect("/")

    else:
        return render_template("register.html")

@app.route("/login", methods=["GET", "POST"])
def login():
    """Log user in"""
    session.clear()

    if request.method == "POST":
        if not request.form.get("username"):
            return "Must provide username. L"
        
        password = request.form.get("password")
        if not password:
            return "Must provide password. L"

        rows = db.execute(
        "SELECT * FROM users WHERE username = ?", request.form.get("username"))


        if len(rows) != 1 or not check_password_hash(rows[0]["hash"], password):
            return "invalid user/password. Lol"

        session["user_id"] = rows[0]["id"]

        return redirect("/")
    
    else:
        return render_template("login.html")

@app.route("/logout")
def logout():
    """Log user out"""

    session.clear()

    return redirect("/")

@app.route("/")
@login_required
def index():
    """Homepage"""
    return render_template("index.html")

@app.route("/search")
@login_required
def search():
    """Search for tabs"""
    # This is thanks to Gemini :)
    query = request.args.get("q")

    if query:
        songs = db.execute(
            "SELECT * FROM tabs WHERE \
            name LIKE ? OR artist LIKE ? \
            ORDER BY name ASC",
            ("%" + query + "%"),
            ("%" + query + "%")
        )

    else:
        songs = []

    return render_template("search.html", songs=songs)

@app.route("/create", methods=["GET", "POST"])
@login_required
def create():
    """Create a new tab"""
    TITLE_LENGTH = 200
    ARTIST_LENGTH = 150
    LINE_LENGTH = 75
    if request.method == "POST":
        name = request.form.get("name")
        name = name.rstrip() # type: ignore
        artist = request.form.get("artist")
        artist = artist.rstrip() #type: ignore
        #print(name, artist)

        if not name:
            return "error, must have name", 403
        if len(name) > TITLE_LENGTH:
            return "Invalid title length", 400

        if not artist:
            return "error, must have artist", 403
        if len(artist) > ARTIST_LENGTH:
            return "Invalid artist length", 400
        parsed_data = {}
        content = ""
        
        #print(request.form)
        for key, value in request.form.items():
            # We already got these
            if key == "name" or key == "artist":
                continue
            
            else:
                # Get the keys organized
                parts = key.split("_")
                section_number = int(parts[1])
                input_type = parts[2]
                #print(f"parts: {parts}")

                if section_number not in parsed_data:
                    parsed_data[section_number] = {'type': '', 'line': {}}
                
                if input_type == 'type':
                    if parsed_data[section_number]['type'] not in VALID_SECTIONS:
                        return "Invalid section type", 400
                    parsed_data[section_number]['type'] = value
                
                elif input_type == 'chords' or input_type == 'lyrics':
                    line_number = int(parts[3])
                    if line_number not in parsed_data[section_number]['line']:
                        parsed_data[section_number]['line'][line_number] = {'chords': '', 'lyrics': ''}
                    if input_type == 'chords':
                        parsed_data[section_number]['line'][line_number]['chords'] = value
                    elif input_type == 'lyrics':
                        parsed_data[section_number]['line'][line_number]['lyrics'] = value
        

        validate_parsed_data(parsed_data)

        #print(f'parsed data: {parsed_data}') 
        for section_number in sorted(parsed_data.keys()):
            #print(section_number, sorted(parsed_data.keys()))
            section = parsed_data[section_number]
            content += f"[{section['type'].capitalize()}]\n"

            for line_number in sorted(section['line'].keys()):
                #print(section_number, line_number)
                line = section['line'][line_number]
                #print(line)
                content += f"{line['chords'].rstrip()}\n{line['lyrics'].rstrip()}\n"
                content += '\n'

        #print(content)
        

        db.execute(
            "INSERT INTO tabs\
            (name, artist, user_id, content) VALUES \
            (?, ?, ?, ?)",
            name, artist, session["user_id"], content
        )

        new_row = db.execute(
            "SELECT id FROM tabs WHERE name = ?",
            name
        )
        new_id = new_row[0]['id']

        return redirect(f"/song/{new_id}")

    else:
        return render_template("create_tab.html")

@app.route("/favorite")
@login_required
def favorite():
    if request.method == "POST":
        return "nothing for now..."

    else:
        return render_template("favorites.html")


# Definitely needed Gemini to explain how this works ðŸ˜…
@app.route("/song/<int:song_id>")
@login_required
def songs(song_id):
    """Display song"""
    song = db.execute(
        "SELECT * FROM tabs WHERE id = ?",
        song_id,
    )

    if not song:
        return "Song not found", 404

    return render_template("song.html", song=song[0])

if __name__ == "__main__":
    app.run(debug=True)
